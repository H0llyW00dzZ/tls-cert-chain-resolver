// Copyright (c) 2025 H0llyW00dzZ All rights reserved.
//
// By accessing or using this software, you agree to be bound by the terms
// of the License Agreement, which you can find at LICENSE files.

// Code generated by go generate; DO NOT EDIT.
// This file is generated from tools/codegen/internal/codegen.go

package mcpserver

import (
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// createPrompts creates and returns all MCP prompt definitions with their handlers.
// It also populates global cached metadata for resource handlers.
//
// This function defines the available MCP prompts for certificate analysis workflows.
// Each prompt provides a structured approach to common certificate-related tasks,
// including analysis, monitoring, auditing, and troubleshooting.
//
// Returns:
//   - []server.ServerPrompt: Slice of server prompt definitions with their handlers
//
// The defined prompts are:
//   - certificate-analysis: Comprehensive certificate chain analysis workflow
//   - expiry-monitoring: Monitor certificate expiration dates and generate renewal alerts
//   - security-audit: Perform comprehensive SSL/TLS security audit on a server
//   - troubleshooting: Troubleshoot common certificate and TLS issues
//   - resource-monitoring: Monitor server resource usage and performance metrics for certificate operations
//
// These prompts guide users through systematic approaches to certificate management
// and provide context-specific instructions for using MCP tools effectively.
func createPrompts() []server.ServerPrompt {
	// Get server cache for storing metadata
	cache := getServerCache()
	cache.prompts = make([]map[string]any, 0, 5)

	prompts := []server.ServerPrompt{
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"certificate-analysis",
					mcp.WithPromptDescription("Comprehensive certificate chain analysis workflow"),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data"),
						mcp.RequiredArgument(),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "analysis", "workflow": "comprehensive"})
				return prompt
			}(),
			Handler: handleCertificateAnalysisPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"expiry-monitoring",
					mcp.WithPromptDescription("Monitor certificate expiration dates and generate renewal alerts"),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"alert_days",
						mcp.ArgumentDescription("Number of days before expiry to alert (default: 30)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "monitoring", "workflow": "renewal"})
				return prompt
			}(),
			Handler: handleExpiryMonitoringPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"security-audit",
					mcp.WithPromptDescription("Perform comprehensive SSL/TLS security audit on a server"),
					mcp.WithArgument(
						"hostname",
						mcp.ArgumentDescription("Target hostname to audit"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"port",
						mcp.ArgumentDescription("Port number (default: 443)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "security", "workflow": "audit"})
				return prompt
			}(),
			Handler: handleSecurityAuditPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"troubleshooting",
					mcp.WithPromptDescription("Troubleshoot common certificate and TLS issues"),
					mcp.WithArgument(
						"issue_type",
						mcp.ArgumentDescription("Type of issue: 'chain', 'validation', 'expiry', 'connection'"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data (for chain/validation/expiry issues)"),
					),
					mcp.WithArgument(
						"hostname",
						mcp.ArgumentDescription("Target hostname (for connection issues)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "support", "workflow": "diagnostic"})
				return prompt
			}(),
			Handler: handleTroubleshootingPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"resource-monitoring",
					mcp.WithPromptDescription("Monitor server resource usage and performance metrics for certificate operations"),
					mcp.WithArgument(
						"monitoring_context",
						mcp.ArgumentDescription("Context for monitoring: 'debugging', 'optimization', 'routine', 'troubleshooting'"),
					),
					mcp.WithArgument(
						"format_preference",
						mcp.ArgumentDescription("Preferred output format: 'json' or 'markdown' (default: json)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "monitoring", "workflow": "performance"})
				return prompt
			}(),
			Handler: handleResourceMonitoringPrompt,
		},
	}

	// Extract metadata from created prompts for resource handlers
	populatePromptMetadataCache(cache, prompts)

	return prompts
}
