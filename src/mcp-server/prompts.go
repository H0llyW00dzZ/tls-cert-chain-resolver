// Copyright (c) 2025 H0llyW00dzZ All rights reserved.
//
// By accessing or using this software, you agree to be bound by the terms
// of the License Agreement, which you can find at LICENSE files.

// Code generated by go generate; DO NOT EDIT.
// This file is generated from tools/codegen/internal/codegen.go

package mcpserver

import (
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// createPrompts creates and returns all MCP prompt definitions with their handlers.
//
// This function generates MCP-compliant prompt definitions that provide structured
// workflows for certificate analysis and management tasks. Each prompt encapsulates
// a specific use case with predefined arguments and execution logic.
//
// Prompts serve as guided workflows that combine multiple MCP tools in logical
// sequences, making complex certificate operations accessible through simple,
// high-level interfaces. They include argument validation, metadata for categorization,
// and handler functions that orchestrate tool execution.
//
// Returns:
//   - []server.ServerPrompt: Slice of server prompt definitions with their handlers
//
// The defined prompts are:
//   - certificate-analysis: Comprehensive certificate chain analysis workflow
//   - expiry-monitoring: Monitor certificate expiration dates and generate renewal alerts
//   - security-audit: Perform comprehensive SSL/TLS security audit on a server
//   - troubleshooting: Troubleshoot common certificate and TLS issues
//   - resource-monitoring: Monitor server resource usage and performance metrics for certificate operations
//
// Prompt Features:
//   - Structured argument definitions with validation and descriptions
//   - Metadata tags for categorization and filtering
//   - Handler functions that implement workflow logic
//   - Integration with MCP tool ecosystem for comprehensive certificate operations
//
// These prompts enable users to perform complex certificate management tasks
// through guided, context-aware workflows rather than individual tool invocations.
func createPrompts() []server.ServerPrompt {
	prompts := []server.ServerPrompt{
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"certificate-analysis",
					mcp.WithPromptDescription("Comprehensive certificate chain analysis workflow"),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data"),
						mcp.RequiredArgument(),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "analysis", "workflow": "comprehensive"})
				return prompt
			}(),
			Handler: handleCertificateAnalysisPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"expiry-monitoring",
					mcp.WithPromptDescription("Monitor certificate expiration dates and generate renewal alerts"),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"alert_days",
						mcp.ArgumentDescription("Number of days before expiry to alert (default: 30)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "monitoring", "workflow": "renewal"})
				return prompt
			}(),
			Handler: handleExpiryMonitoringPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"security-audit",
					mcp.WithPromptDescription("Perform comprehensive SSL/TLS security audit on a server"),
					mcp.WithArgument(
						"hostname",
						mcp.ArgumentDescription("Target hostname to audit"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"port",
						mcp.ArgumentDescription("Port number (default: 443)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "security", "workflow": "audit"})
				return prompt
			}(),
			Handler: handleSecurityAuditPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"troubleshooting",
					mcp.WithPromptDescription("Troubleshoot common certificate and TLS issues"),
					mcp.WithArgument(
						"issue_type",
						mcp.ArgumentDescription("Type of issue: 'chain', 'validation', 'expiry', 'connection'"),
						mcp.RequiredArgument(),
					),
					mcp.WithArgument(
						"certificate_path",
						mcp.ArgumentDescription("Path to certificate file or base64-encoded certificate data (for chain/validation/expiry issues)"),
					),
					mcp.WithArgument(
						"hostname",
						mcp.ArgumentDescription("Target hostname (for connection issues)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "support", "workflow": "diagnostic"})
				return prompt
			}(),
			Handler: handleTroubleshootingPrompt,
		},
		{
			Prompt: func() mcp.Prompt {
				prompt := mcp.NewPrompt(
					"resource-monitoring",
					mcp.WithPromptDescription("Monitor server resource usage and performance metrics for certificate operations"),
					mcp.WithArgument(
						"monitoring_context",
						mcp.ArgumentDescription("Context for monitoring: 'debugging', 'optimization', 'routine', 'troubleshooting'"),
					),
					mcp.WithArgument(
						"format_preference",
						mcp.ArgumentDescription("Preferred output format: 'json' or 'markdown' (default: json)"),
					),
				)
				prompt.Meta = mcp.NewMetaFromMap(map[string]any{"category": "monitoring", "workflow": "performance"})
				return prompt
			}(),
			Handler: handleResourceMonitoringPrompt,
		},
	}

	return prompts
}
